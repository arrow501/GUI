import java.util.Timer;
import java.util.TimerTask;

// The Main class that tests the producer-consumer problem 
public class Main {

    public static void main(String[] args) {
        // create a buffer with capacity 10
        Buffer buffer = new Buffer(10);

        // create a producer and a consumer
        Producer producer = new Producer(buffer);
        Consumer consumer = new Consumer(buffer);

        // create and start the producer and consumer threads
        Thread producerThread = new Thread(producer);
        Thread consumerThread = new Thread(consumer);
        producerThread.start();
        consumerThread.start();

        // create a timer task that will interrupt the threads after 15 seconds
        TimerTask task = new TimerTask() {
            @Override
            public void run() {
                // interrupt the producer and consumer threads
                producerThread.interrupt();
                consumerThread.interrupt();
                // cancel the timer
                cancel();
                System.exit(0);
            }
        };

        // create a timer and schedule the task to run after 15 seconds
        Timer timer = new Timer();
        timer.schedule(task, 5 * 1000);
    }
}

class Message {
    private int id; // a unique identifier for the product private
    int data; // a random integer generated by the producer

    // constructor
    public Message(int id, int data) {
        this.id = id;
        this.data = data;
    }

    // getters
    public int getId() {
        return id;
    }

    public int getData() {
        return data;
    }
}

class Buffer {

    private Message[] array; // an array to store the products
    private int size; // the current number of products in the buffer
    private int capacity; // the maximum number of products that the buffer can hold
    private int head; // the index of the first product in the buffer
    private int tail; // the index of the last product in the buffer

    // the index of the last product in the buffer
    // constructor
    public Buffer(int capacity) {
        this.capacity = capacity;
        array = new Message[capacity];
        size = 0;
        head = 0;
        tail = -1;
    }

    // synchronized method to put a product into the buffer
    public synchronized void put(Message message) throws InterruptedException {
        // wait until there is space in the buffer
        while (size == capacity) {
            wait();
        }
        // increment the tail index and wrap around if necessary
        tail = (tail + 1) % capacity;
        // insert the product at the tail index
        array[tail] = message;
        // increment the size
        size++;
        // notify any waiting threads that the buffer has changed
        notifyAll();
    }

    // synchronized method to get a product from the buffer
    public synchronized Message get() throws InterruptedException {
        // wait until there is a product in the buffer
        while (size == 0) {
            wait();
        }
        // get the product at the head index
        Message message = array[head];
        // increment the head index and wrap around if necessary
        head = (head + 1) % capacity;
        // decrement the size
        size--;
        // notify any waiting threads that the buffer has changed
        notifyAll();
        // return the product
        return message;
    }
}

// The Producer class represents a producer thread that generates and puts
// products into the buffer
class Producer implements Runnable {
    private Buffer buffer;

    // a reference to the shared buffer
    // constructor
    public Producer(Buffer buffer) {
        this.buffer = buffer;
    }

    @Override
    public void run() {
        int id = 0; // a counter for generating unique ids for products
        while (true) {
            try {
                // generate a random integer between 0 and 100 as the product data
                int data = (int) (Math.random() * 100);
                // create a new product with an id and data
                Message message = new Message(id, data);
                // put the product into the buffer
                buffer.put(message);
                // print a message indicating that a product has been produced
                System.out.println("Producer produced " + message.getId() + " with data " + message.getData());
                // increment the id counter
                id++;
                // sleep for a random time between 0 and 2 seconds
                Thread.sleep((long) (Math.random() * 2000));
            } catch (InterruptedException e) {
                // e.printStackTrace();
                return;
            }
        }
    }
}

// The Consumer class represents a consumer thread that gets and consumes
// products from the buffer
class Consumer implements Runnable {
    private Buffer buffer; // a reference to the shared buffer

    // constructor
    public Consumer(Buffer buffer) {
        this.buffer = buffer;
    }

    @Override
    public void run() {
        while (true) {
            try {
                // get a product from the buffer
                Message message = buffer.get();
                // print a message indicating that a product has been consumed
                System.out.println("Consumer consumed " + message.getId() + " with data " + message.getData());
                // sleep for a random time between 0 and 2 seconds
                Thread.sleep((long) (Math.random() * 2000));
            } catch (InterruptedException e) {
                // handle the interruption
                // e.printStackTrace();
                // break the loop and exit the thread
                return;
            }
        }
    }
}
